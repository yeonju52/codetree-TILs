# [팩맨 | 2021 하반기 오후 1번 문제](https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/pacman)

> 문제 링크: https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/pacman

| 수행 시간 | 메모리 사용량 | 날짜 / 시간            |
| ----- | ------- | ------------------ |
| 8ms   | 0MB     | 2025-09-05 / 13:37 |

* **풀이 소요 시간:** 2시간
* **틀린 이유:**

  1. 몬스터를 `vector`로 관리 → 빈번한 삭제로 시간초과 발생
  2. `dead` 수명 잘못 설정 (2로 설정 → 3으로 설정해야 바로 감소(--)시키는 걸 대응할 수 있음)

---

## 1. 상태 관리 전략

### 1-1. 일반 상태 관리

* **목적:** 몬스터 위치/방향 등 기본 상태 추적
* **방법:**

  * **정적 배열:** `board[x][y][dir]` → 칸 단위 수치/카운트 기록

    * 장점: 상수 시간 접근, 반복 이동/갱신 효율적
  * **동적 배열(vector):** `vector<obj>` → 개별 객체 추적, 삭제/복제 가능

    * 단점: `erase` O(N), 빈번하면 시간초과/버그 발생

### 1-2. 죽은 상태 관리 (턴 기반 소멸)

* **추천:** 정적 배열 기반 격자 (`dead[x][y]`)

  * 칸 단위 존재/수명 고정 → 중복/erase 문제 없음, 턴 감소 처리 명확
* **방법:**

  ```cpp
  // 몬스터 이동 시 접근 제한
  if (dead[nx][ny] > 0) continue;

  // 팩맨 먹음 처리
  dead[x][y] = 3;       // 2턴 유지 효과
  board[x][y][d] = 0;

  // 턴 종료 시 소멸
  for (int i=0;i<N;i++)
      for (int j=0;j<N;j++)
          if (dead[i][j]>0) dead[i][j]--;
  ```

---

## 2. 구현 방식 비교

| 항목         | 배열 버전 (`dead[x][y]`) | 벡터 버전 (`vector<dead>`)       |
| ---------- | -------------------- | ---------------------------- |
| 판정 비용      | O(1)                 | O(D) 또는 O(1)+O(D) (보조 격자 필요) |
| 소멸 비용      | O(16) (상수)           | O(D) + erase 비용              |
| 구현 난이도     | 낮음 (버그 적음)           | 높음 (중복/erase/동기화 문제)         |
| 동일 칸 중복 시체 | 자동 덮어쓰기 (문제 없음)      | 중복 관리 필요                     |
| 추천도        | ⭐⭐⭐⭐                 | ⭐ (특수 요구 있을 때만)              |

---

## 3. 선택 기준

* **칸 단위 의미 + 유지 시간 고정** → **정적 배열** 정석
* **개별 시체 속성/정체성 필요** → **벡터 + 보조 격자** 사용
